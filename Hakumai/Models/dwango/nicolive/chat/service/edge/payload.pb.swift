// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: dwango/nicolive/chat/service/edge/payload.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

struct Dwango_Nicolive_Chat_Service_Edge_ChunkedMessage: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var meta: Dwango_Nicolive_Chat_Service_Edge_ChunkedMessage.Meta {
        get {return _storage._meta ?? Dwango_Nicolive_Chat_Service_Edge_ChunkedMessage.Meta()}
        set {_uniqueStorage()._meta = newValue}
    }
    /// Returns true if `meta` has been explicitly set.
    var hasMeta: Bool {return _storage._meta != nil}
    /// Clears the value of `meta`. Subsequent reads from it will return its default value.
    mutating func clearMeta() {_uniqueStorage()._meta = nil}

    var payload: OneOf_Payload? {
        get {return _storage._payload}
        set {_uniqueStorage()._payload = newValue}
    }

    var message: Dwango_Nicolive_Chat_Data_NicoliveMessage {
        get {
            if case .message(let v)? = _storage._payload {return v}
            return Dwango_Nicolive_Chat_Data_NicoliveMessage()
        }
        set {_uniqueStorage()._payload = .message(newValue)}
    }

    var state: Dwango_Nicolive_Chat_Data_NicoliveState {
        get {
            if case .state(let v)? = _storage._payload {return v}
            return Dwango_Nicolive_Chat_Data_NicoliveState()
        }
        set {_uniqueStorage()._payload = .state(newValue)}
    }

    var signal: Dwango_Nicolive_Chat_Service_Edge_ChunkedMessage.Signal {
        get {
            if case .signal(let v)? = _storage._payload {return v}
            return .flushed
        }
        set {_uniqueStorage()._payload = .signal(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Payload: Equatable, Sendable {
        case message(Dwango_Nicolive_Chat_Data_NicoliveMessage)
        case state(Dwango_Nicolive_Chat_Data_NicoliveState)
        case signal(Dwango_Nicolive_Chat_Service_Edge_ChunkedMessage.Signal)

    }

    enum Signal: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case flushed // = 0
        case UNRECOGNIZED(Int)

        init() {
            self = .flushed
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .flushed
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .flushed: return 0
            case .UNRECOGNIZED(let i): return i
            }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Dwango_Nicolive_Chat_Service_Edge_ChunkedMessage.Signal] = [
            .flushed
        ]

    }

    struct Meta: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var id: String = String()

        var at: SwiftProtobuf.Google_Protobuf_Timestamp {
            get {return _at ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
            set {_at = newValue}
        }
        /// Returns true if `at` has been explicitly set.
        var hasAt: Bool {return self._at != nil}
        /// Clears the value of `at`. Subsequent reads from it will return its default value.
        mutating func clearAt() {self._at = nil}

        var origin: Dwango_Nicolive_Chat_Data_NicoliveOrigin {
            get {return _origin ?? Dwango_Nicolive_Chat_Data_NicoliveOrigin()}
            set {_origin = newValue}
        }
        /// Returns true if `origin` has been explicitly set.
        var hasOrigin: Bool {return self._origin != nil}
        /// Clears the value of `origin`. Subsequent reads from it will return its default value.
        mutating func clearOrigin() {self._origin = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _at: SwiftProtobuf.Google_Protobuf_Timestamp?
        fileprivate var _origin: Dwango_Nicolive_Chat_Data_NicoliveOrigin?
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

struct Dwango_Nicolive_Chat_Service_Edge_PackedSegment: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var messages: [Dwango_Nicolive_Chat_Service_Edge_ChunkedMessage] = []

    var next: Dwango_Nicolive_Chat_Service_Edge_PackedSegment.Next {
        get {return _next ?? Dwango_Nicolive_Chat_Service_Edge_PackedSegment.Next()}
        set {_next = newValue}
    }
    /// Returns true if `next` has been explicitly set.
    var hasNext: Bool {return self._next != nil}
    /// Clears the value of `next`. Subsequent reads from it will return its default value.
    mutating func clearNext() {self._next = nil}

    var snapshot: Dwango_Nicolive_Chat_Service_Edge_PackedSegment.StateSnapshot {
        get {return _snapshot ?? Dwango_Nicolive_Chat_Service_Edge_PackedSegment.StateSnapshot()}
        set {_snapshot = newValue}
    }
    /// Returns true if `snapshot` has been explicitly set.
    var hasSnapshot: Bool {return self._snapshot != nil}
    /// Clears the value of `snapshot`. Subsequent reads from it will return its default value.
    mutating func clearSnapshot() {self._snapshot = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Next: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var uri: String = String()

        var unknownFields = SwiftProtobuf.UnknownStorage()
    }

    struct StateSnapshot: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var uri: String = String()

        var unknownFields = SwiftProtobuf.UnknownStorage()
    }

    init() {}

    fileprivate var _next: Dwango_Nicolive_Chat_Service_Edge_PackedSegment.Next?
    fileprivate var _snapshot: Dwango_Nicolive_Chat_Service_Edge_PackedSegment.StateSnapshot?
}

struct Dwango_Nicolive_Chat_Service_Edge_ChunkedEntry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var entry: Dwango_Nicolive_Chat_Service_Edge_ChunkedEntry.OneOf_Entry?

    var backward: Dwango_Nicolive_Chat_Service_Edge_BackwardSegment {
        get {
            if case .backward(let v)? = entry {return v}
            return Dwango_Nicolive_Chat_Service_Edge_BackwardSegment()
        }
        set {entry = .backward(newValue)}
    }

    var previous: Dwango_Nicolive_Chat_Service_Edge_MessageSegment {
        get {
            if case .previous(let v)? = entry {return v}
            return Dwango_Nicolive_Chat_Service_Edge_MessageSegment()
        }
        set {entry = .previous(newValue)}
    }

    var segment: Dwango_Nicolive_Chat_Service_Edge_MessageSegment {
        get {
            if case .segment(let v)? = entry {return v}
            return Dwango_Nicolive_Chat_Service_Edge_MessageSegment()
        }
        set {entry = .segment(newValue)}
    }

    var next: Dwango_Nicolive_Chat_Service_Edge_ChunkedEntry.ReadyForNext {
        get {
            if case .next(let v)? = entry {return v}
            return Dwango_Nicolive_Chat_Service_Edge_ChunkedEntry.ReadyForNext()
        }
        set {entry = .next(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Entry: Equatable, Sendable {
        case backward(Dwango_Nicolive_Chat_Service_Edge_BackwardSegment)
        case previous(Dwango_Nicolive_Chat_Service_Edge_MessageSegment)
        case segment(Dwango_Nicolive_Chat_Service_Edge_MessageSegment)
        case next(Dwango_Nicolive_Chat_Service_Edge_ChunkedEntry.ReadyForNext)

    }

    struct ReadyForNext: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var at: Int64 = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()
    }

    init() {}
}

struct Dwango_Nicolive_Chat_Service_Edge_MessageSegment: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var from: SwiftProtobuf.Google_Protobuf_Timestamp {
        get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
        set {_from = newValue}
    }
    /// Returns true if `from` has been explicitly set.
    var hasFrom: Bool {return self._from != nil}
    /// Clears the value of `from`. Subsequent reads from it will return its default value.
    mutating func clearFrom() {self._from = nil}

    var until: SwiftProtobuf.Google_Protobuf_Timestamp {
        get {return _until ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
        set {_until = newValue}
    }
    /// Returns true if `until` has been explicitly set.
    var hasUntil: Bool {return self._until != nil}
    /// Clears the value of `until`. Subsequent reads from it will return its default value.
    mutating func clearUntil() {self._until = nil}

    var uri: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp?
    fileprivate var _until: SwiftProtobuf.Google_Protobuf_Timestamp?
}

struct Dwango_Nicolive_Chat_Service_Edge_BackwardSegment: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var until: SwiftProtobuf.Google_Protobuf_Timestamp {
        get {return _until ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
        set {_until = newValue}
    }
    /// Returns true if `until` has been explicitly set.
    var hasUntil: Bool {return self._until != nil}
    /// Clears the value of `until`. Subsequent reads from it will return its default value.
    mutating func clearUntil() {self._until = nil}

    var segment: Dwango_Nicolive_Chat_Service_Edge_PackedSegment.Next {
        get {return _segment ?? Dwango_Nicolive_Chat_Service_Edge_PackedSegment.Next()}
        set {_segment = newValue}
    }
    /// Returns true if `segment` has been explicitly set.
    var hasSegment: Bool {return self._segment != nil}
    /// Clears the value of `segment`. Subsequent reads from it will return its default value.
    mutating func clearSegment() {self._segment = nil}

    var snapshot: Dwango_Nicolive_Chat_Service_Edge_PackedSegment.StateSnapshot {
        get {return _snapshot ?? Dwango_Nicolive_Chat_Service_Edge_PackedSegment.StateSnapshot()}
        set {_snapshot = newValue}
    }
    /// Returns true if `snapshot` has been explicitly set.
    var hasSnapshot: Bool {return self._snapshot != nil}
    /// Clears the value of `snapshot`. Subsequent reads from it will return its default value.
    mutating func clearSnapshot() {self._snapshot = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _until: SwiftProtobuf.Google_Protobuf_Timestamp?
    fileprivate var _segment: Dwango_Nicolive_Chat_Service_Edge_PackedSegment.Next?
    fileprivate var _snapshot: Dwango_Nicolive_Chat_Service_Edge_PackedSegment.StateSnapshot?
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "dwango.nicolive.chat.service.edge"

extension Dwango_Nicolive_Chat_Service_Edge_ChunkedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ChunkedMessage"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "meta"),
        2: .same(proto: "message"),
        4: .same(proto: "state"),
        5: .same(proto: "signal")
    ]

    fileprivate class _StorageClass {
        var _meta: Dwango_Nicolive_Chat_Service_Edge_ChunkedMessage.Meta?
        var _payload: Dwango_Nicolive_Chat_Service_Edge_ChunkedMessage.OneOf_Payload?

        #if swift(>=5.10)
        // This property is used as the initial default value for new instances of the type.
        // The type itself is protecting the reference to its storage via CoW semantics.
        // This will force a copy to be made of this reference when the first mutation occurs;
        // hence, it is safe to mark this as `nonisolated(unsafe)`.
        static nonisolated(unsafe) let defaultInstance = _StorageClass()
        #else
        static let defaultInstance = _StorageClass()
        #endif

        private init() {}

        init(copying source: _StorageClass) {
            _meta = source._meta
            _payload = source._payload
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try { try decoder.decodeSingularMessageField(value: &_storage._meta) }()
                case 2: try {
                    var v: Dwango_Nicolive_Chat_Data_NicoliveMessage?
                    var hadOneofValue = false
                    if let current = _storage._payload {
                        hadOneofValue = true
                        if case .message(let m) = current {v = m}
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue {try decoder.handleConflictingOneOf()}
                        _storage._payload = .message(v)
                    }
                }()
                case 4: try {
                    var v: Dwango_Nicolive_Chat_Data_NicoliveState?
                    var hadOneofValue = false
                    if let current = _storage._payload {
                        hadOneofValue = true
                        if case .state(let m) = current {v = m}
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue {try decoder.handleConflictingOneOf()}
                        _storage._payload = .state(v)
                    }
                }()
                case 5: try {
                    var v: Dwango_Nicolive_Chat_Service_Edge_ChunkedMessage.Signal?
                    try decoder.decodeSingularEnumField(value: &v)
                    if let v = v {
                        if _storage._payload != nil {try decoder.handleConflictingOneOf()}
                        _storage._payload = .signal(v)
                    }
                }()
                default: break
                }
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            try { if let v = _storage._meta {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            } }()
            switch _storage._payload {
            case .message?: try {
                guard case .message(let v)? = _storage._payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
            case .state?: try {
                guard case .state(let v)? = _storage._payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
            case .signal?: try {
                guard case .signal(let v)? = _storage._payload else { preconditionFailure() }
                try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
            }()
            case nil: break
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Service_Edge_ChunkedMessage, rhs: Dwango_Nicolive_Chat_Service_Edge_ChunkedMessage) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._meta != rhs_storage._meta {return false}
                if _storage._payload != rhs_storage._payload {return false}
                return true
            }
            if !storagesAreEqual {return false}
        }
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Service_Edge_ChunkedMessage.Signal: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Flushed")
    ]
}

extension Dwango_Nicolive_Chat_Service_Edge_ChunkedMessage.Meta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Dwango_Nicolive_Chat_Service_Edge_ChunkedMessage.protoMessageName + ".Meta"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "at"),
        3: .same(proto: "origin")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._at) }()
            case 3: try { try decoder.decodeSingularMessageField(value: &self._origin) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !self.id.isEmpty {
            try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
        }
        try { if let v = self._at {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._origin {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Service_Edge_ChunkedMessage.Meta, rhs: Dwango_Nicolive_Chat_Service_Edge_ChunkedMessage.Meta) -> Bool {
        if lhs.id != rhs.id {return false}
        if lhs._at != rhs._at {return false}
        if lhs._origin != rhs._origin {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Service_Edge_PackedSegment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PackedSegment"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "messages"),
        2: .same(proto: "next"),
        3: .same(proto: "snapshot")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._next) }()
            case 3: try { try decoder.decodeSingularMessageField(value: &self._snapshot) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !self.messages.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
        }
        try { if let v = self._next {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._snapshot {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Service_Edge_PackedSegment, rhs: Dwango_Nicolive_Chat_Service_Edge_PackedSegment) -> Bool {
        if lhs.messages != rhs.messages {return false}
        if lhs._next != rhs._next {return false}
        if lhs._snapshot != rhs._snapshot {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Service_Edge_PackedSegment.Next: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Dwango_Nicolive_Chat_Service_Edge_PackedSegment.protoMessageName + ".Next"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "uri")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.uri.isEmpty {
            try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Service_Edge_PackedSegment.Next, rhs: Dwango_Nicolive_Chat_Service_Edge_PackedSegment.Next) -> Bool {
        if lhs.uri != rhs.uri {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Service_Edge_PackedSegment.StateSnapshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Dwango_Nicolive_Chat_Service_Edge_PackedSegment.protoMessageName + ".StateSnapshot"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "uri")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.uri.isEmpty {
            try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Service_Edge_PackedSegment.StateSnapshot, rhs: Dwango_Nicolive_Chat_Service_Edge_PackedSegment.StateSnapshot) -> Bool {
        if lhs.uri != rhs.uri {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Service_Edge_ChunkedEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ChunkedEntry"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        2: .same(proto: "backward"),
        3: .same(proto: "previous"),
        1: .same(proto: "segment"),
        4: .same(proto: "next")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                var v: Dwango_Nicolive_Chat_Service_Edge_MessageSegment?
                var hadOneofValue = false
                if let current = self.entry {
                    hadOneofValue = true
                    if case .segment(let m) = current {v = m}
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v {
                    if hadOneofValue {try decoder.handleConflictingOneOf()}
                    self.entry = .segment(v)
                }
            }()
            case 2: try {
                var v: Dwango_Nicolive_Chat_Service_Edge_BackwardSegment?
                var hadOneofValue = false
                if let current = self.entry {
                    hadOneofValue = true
                    if case .backward(let m) = current {v = m}
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v {
                    if hadOneofValue {try decoder.handleConflictingOneOf()}
                    self.entry = .backward(v)
                }
            }()
            case 3: try {
                var v: Dwango_Nicolive_Chat_Service_Edge_MessageSegment?
                var hadOneofValue = false
                if let current = self.entry {
                    hadOneofValue = true
                    if case .previous(let m) = current {v = m}
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v {
                    if hadOneofValue {try decoder.handleConflictingOneOf()}
                    self.entry = .previous(v)
                }
            }()
            case 4: try {
                var v: Dwango_Nicolive_Chat_Service_Edge_ChunkedEntry.ReadyForNext?
                var hadOneofValue = false
                if let current = self.entry {
                    hadOneofValue = true
                    if case .next(let m) = current {v = m}
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v {
                    if hadOneofValue {try decoder.handleConflictingOneOf()}
                    self.entry = .next(v)
                }
            }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch self.entry {
        case .segment?: try {
            guard case .segment(let v)? = self.entry else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }()
        case .backward?: try {
            guard case .backward(let v)? = self.entry else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        }()
        case .previous?: try {
            guard case .previous(let v)? = self.entry else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        }()
        case .next?: try {
            guard case .next(let v)? = self.entry else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Service_Edge_ChunkedEntry, rhs: Dwango_Nicolive_Chat_Service_Edge_ChunkedEntry) -> Bool {
        if lhs.entry != rhs.entry {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Service_Edge_ChunkedEntry.ReadyForNext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Dwango_Nicolive_Chat_Service_Edge_ChunkedEntry.protoMessageName + ".ReadyForNext"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "at")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularInt64Field(value: &self.at) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.at != 0 {
            try visitor.visitSingularInt64Field(value: self.at, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Service_Edge_ChunkedEntry.ReadyForNext, rhs: Dwango_Nicolive_Chat_Service_Edge_ChunkedEntry.ReadyForNext) -> Bool {
        if lhs.at != rhs.at {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Service_Edge_MessageSegment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".MessageSegment"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "from"),
        2: .same(proto: "until"),
        3: .same(proto: "uri")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._from) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._until) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self.uri) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._from {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._until {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if !self.uri.isEmpty {
            try visitor.visitSingularStringField(value: self.uri, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Service_Edge_MessageSegment, rhs: Dwango_Nicolive_Chat_Service_Edge_MessageSegment) -> Bool {
        if lhs._from != rhs._from {return false}
        if lhs._until != rhs._until {return false}
        if lhs.uri != rhs.uri {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Service_Edge_BackwardSegment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".BackwardSegment"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "until"),
        2: .same(proto: "segment"),
        3: .same(proto: "snapshot")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._until) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._segment) }()
            case 3: try { try decoder.decodeSingularMessageField(value: &self._snapshot) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._until {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._segment {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._snapshot {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Service_Edge_BackwardSegment, rhs: Dwango_Nicolive_Chat_Service_Edge_BackwardSegment) -> Bool {
        if lhs._until != rhs._until {return false}
        if lhs._segment != rhs._segment {return false}
        if lhs._snapshot != rhs._snapshot {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}
