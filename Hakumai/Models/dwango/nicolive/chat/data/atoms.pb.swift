// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: dwango/nicolive/chat/data/atoms.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

struct Dwango_Nicolive_Chat_Data_Chat: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var content: String = String()

    var vpos: Int32 = 0

    var accountStatus: Dwango_Nicolive_Chat_Data_Chat.AccountStatus = .standard

    var name: String {
        get {return _name ?? String()}
        set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    mutating func clearName() {self._name = nil}

    var rawUserID: Int64 {
        get {return _rawUserID ?? 0}
        set {_rawUserID = newValue}
    }
    /// Returns true if `rawUserID` has been explicitly set.
    var hasRawUserID: Bool {return self._rawUserID != nil}
    /// Clears the value of `rawUserID`. Subsequent reads from it will return its default value.
    mutating func clearRawUserID() {self._rawUserID = nil}

    var hashedUserID: String {
        get {return _hashedUserID ?? String()}
        set {_hashedUserID = newValue}
    }
    /// Returns true if `hashedUserID` has been explicitly set.
    var hasHashedUserID: Bool {return self._hashedUserID != nil}
    /// Clears the value of `hashedUserID`. Subsequent reads from it will return its default value.
    mutating func clearHashedUserID() {self._hashedUserID = nil}

    var modifier: Dwango_Nicolive_Chat_Data_Chat.Modifier {
        get {return _modifier ?? Dwango_Nicolive_Chat_Data_Chat.Modifier()}
        set {_modifier = newValue}
    }
    /// Returns true if `modifier` has been explicitly set.
    var hasModifier: Bool {return self._modifier != nil}
    /// Clears the value of `modifier`. Subsequent reads from it will return its default value.
    mutating func clearModifier() {self._modifier = nil}

    var no: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum AccountStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case standard // = 0
        case premium // = 1
        case UNRECOGNIZED(Int)

        init() {
            self = .standard
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .standard
            case 1: self = .premium
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .standard: return 0
            case .premium: return 1
            case .UNRECOGNIZED(let i): return i
            }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Dwango_Nicolive_Chat_Data_Chat.AccountStatus] = [
            .standard,
            .premium
        ]

    }

    struct Modifier: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var position: Dwango_Nicolive_Chat_Data_Chat.Modifier.Pos = .naka

        var size: Dwango_Nicolive_Chat_Data_Chat.Modifier.Size = .medium

        var color: Dwango_Nicolive_Chat_Data_Chat.Modifier.OneOf_Color?

        var namedColor: Dwango_Nicolive_Chat_Data_Chat.Modifier.ColorName {
            get {
                if case .namedColor(let v)? = color {return v}
                return .white
            }
            set {color = .namedColor(newValue)}
        }

        var fullColor: Dwango_Nicolive_Chat_Data_Chat.Modifier.FullColor {
            get {
                if case .fullColor(let v)? = color {return v}
                return Dwango_Nicolive_Chat_Data_Chat.Modifier.FullColor()
            }
            set {color = .fullColor(newValue)}
        }

        var font: Dwango_Nicolive_Chat_Data_Chat.Modifier.Font = .defont

        var opacity: Dwango_Nicolive_Chat_Data_Chat.Modifier.Opacity = .normal

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum OneOf_Color: Equatable, Sendable {
            case namedColor(Dwango_Nicolive_Chat_Data_Chat.Modifier.ColorName)
            case fullColor(Dwango_Nicolive_Chat_Data_Chat.Modifier.FullColor)

        }

        enum Pos: SwiftProtobuf.Enum, Swift.CaseIterable {
            typealias RawValue = Int
            case naka // = 0
            case shita // = 1
            case ue // = 2
            case UNRECOGNIZED(Int)

            init() {
                self = .naka
            }

            init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .naka
                case 1: self = .shita
                case 2: self = .ue
                default: self = .UNRECOGNIZED(rawValue)
                }
            }

            var rawValue: Int {
                switch self {
                case .naka: return 0
                case .shita: return 1
                case .ue: return 2
                case .UNRECOGNIZED(let i): return i
                }
            }

            // The compiler won't synthesize support with the UNRECOGNIZED case.
            static let allCases: [Dwango_Nicolive_Chat_Data_Chat.Modifier.Pos] = [
                .naka,
                .shita,
                .ue
            ]

        }

        enum Size: SwiftProtobuf.Enum, Swift.CaseIterable {
            typealias RawValue = Int
            case medium // = 0
            case small // = 1
            case big // = 2
            case UNRECOGNIZED(Int)

            init() {
                self = .medium
            }

            init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .medium
                case 1: self = .small
                case 2: self = .big
                default: self = .UNRECOGNIZED(rawValue)
                }
            }

            var rawValue: Int {
                switch self {
                case .medium: return 0
                case .small: return 1
                case .big: return 2
                case .UNRECOGNIZED(let i): return i
                }
            }

            // The compiler won't synthesize support with the UNRECOGNIZED case.
            static let allCases: [Dwango_Nicolive_Chat_Data_Chat.Modifier.Size] = [
                .medium,
                .small,
                .big
            ]

        }

        enum ColorName: SwiftProtobuf.Enum, Swift.CaseIterable {
            typealias RawValue = Int
            case white // = 0
            case red // = 1
            case pink // = 2
            case orange // = 3
            case yellow // = 4
            case green // = 5
            case cyan // = 6
            case blue // = 7
            case purple // = 8
            case black // = 9
            case white2 // = 10
            case red2 // = 11
            case pink2 // = 12
            case orange2 // = 13
            case yellow2 // = 14
            case green2 // = 15
            case cyan2 // = 16
            case blue2 // = 17
            case purple2 // = 18
            case black2 // = 19
            case UNRECOGNIZED(Int)

            init() {
                self = .white
            }

            init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .white
                case 1: self = .red
                case 2: self = .pink
                case 3: self = .orange
                case 4: self = .yellow
                case 5: self = .green
                case 6: self = .cyan
                case 7: self = .blue
                case 8: self = .purple
                case 9: self = .black
                case 10: self = .white2
                case 11: self = .red2
                case 12: self = .pink2
                case 13: self = .orange2
                case 14: self = .yellow2
                case 15: self = .green2
                case 16: self = .cyan2
                case 17: self = .blue2
                case 18: self = .purple2
                case 19: self = .black2
                default: self = .UNRECOGNIZED(rawValue)
                }
            }

            var rawValue: Int {
                switch self {
                case .white: return 0
                case .red: return 1
                case .pink: return 2
                case .orange: return 3
                case .yellow: return 4
                case .green: return 5
                case .cyan: return 6
                case .blue: return 7
                case .purple: return 8
                case .black: return 9
                case .white2: return 10
                case .red2: return 11
                case .pink2: return 12
                case .orange2: return 13
                case .yellow2: return 14
                case .green2: return 15
                case .cyan2: return 16
                case .blue2: return 17
                case .purple2: return 18
                case .black2: return 19
                case .UNRECOGNIZED(let i): return i
                }
            }

            // The compiler won't synthesize support with the UNRECOGNIZED case.
            static let allCases: [Dwango_Nicolive_Chat_Data_Chat.Modifier.ColorName] = [
                .white,
                .red,
                .pink,
                .orange,
                .yellow,
                .green,
                .cyan,
                .blue,
                .purple,
                .black,
                .white2,
                .red2,
                .pink2,
                .orange2,
                .yellow2,
                .green2,
                .cyan2,
                .blue2,
                .purple2,
                .black2
            ]

        }

        enum Font: SwiftProtobuf.Enum, Swift.CaseIterable {
            typealias RawValue = Int
            case defont // = 0
            case mincho // = 1
            case gothic // = 2
            case UNRECOGNIZED(Int)

            init() {
                self = .defont
            }

            init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .defont
                case 1: self = .mincho
                case 2: self = .gothic
                default: self = .UNRECOGNIZED(rawValue)
                }
            }

            var rawValue: Int {
                switch self {
                case .defont: return 0
                case .mincho: return 1
                case .gothic: return 2
                case .UNRECOGNIZED(let i): return i
                }
            }

            // The compiler won't synthesize support with the UNRECOGNIZED case.
            static let allCases: [Dwango_Nicolive_Chat_Data_Chat.Modifier.Font] = [
                .defont,
                .mincho,
                .gothic
            ]

        }

        enum Opacity: SwiftProtobuf.Enum, Swift.CaseIterable {
            typealias RawValue = Int
            case normal // = 0
            case translucent // = 1
            case UNRECOGNIZED(Int)

            init() {
                self = .normal
            }

            init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .normal
                case 1: self = .translucent
                default: self = .UNRECOGNIZED(rawValue)
                }
            }

            var rawValue: Int {
                switch self {
                case .normal: return 0
                case .translucent: return 1
                case .UNRECOGNIZED(let i): return i
                }
            }

            // The compiler won't synthesize support with the UNRECOGNIZED case.
            static let allCases: [Dwango_Nicolive_Chat_Data_Chat.Modifier.Opacity] = [
                .normal,
                .translucent
            ]

        }

        struct FullColor: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            var r: Int32 = 0

            var g: Int32 = 0

            var b: Int32 = 0

            var unknownFields = SwiftProtobuf.UnknownStorage()
        }

        init() {}
    }

    init() {}

    fileprivate var _name: String?
    fileprivate var _rawUserID: Int64?
    fileprivate var _hashedUserID: String?
    fileprivate var _modifier: Dwango_Nicolive_Chat_Data_Chat.Modifier?
}

struct Dwango_Nicolive_Chat_Data_OperatorComment: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var content: String = String()

    var name: String {
        get {return _name ?? String()}
        set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    mutating func clearName() {self._name = nil}

    var modifier: Dwango_Nicolive_Chat_Data_Chat.Modifier {
        get {return _modifier ?? Dwango_Nicolive_Chat_Data_Chat.Modifier()}
        set {_modifier = newValue}
    }
    /// Returns true if `modifier` has been explicitly set.
    var hasModifier: Bool {return self._modifier != nil}
    /// Clears the value of `modifier`. Subsequent reads from it will return its default value.
    mutating func clearModifier() {self._modifier = nil}

    var link: String {
        get {return _link ?? String()}
        set {_link = newValue}
    }
    /// Returns true if `link` has been explicitly set.
    var hasLink: Bool {return self._link != nil}
    /// Clears the value of `link`. Subsequent reads from it will return its default value.
    mutating func clearLink() {self._link = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _name: String?
    fileprivate var _modifier: Dwango_Nicolive_Chat_Data_Chat.Modifier?
    fileprivate var _link: String?
}

struct Dwango_Nicolive_Chat_Data_Jump: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var content: String = String()

    var message: String = String()

    var wait: SwiftProtobuf.Google_Protobuf_Duration {
        get {return _wait ?? SwiftProtobuf.Google_Protobuf_Duration()}
        set {_wait = newValue}
    }
    /// Returns true if `wait` has been explicitly set.
    var hasWait: Bool {return self._wait != nil}
    /// Clears the value of `wait`. Subsequent reads from it will return its default value.
    mutating func clearWait() {self._wait = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _wait: SwiftProtobuf.Google_Protobuf_Duration?
}

struct Dwango_Nicolive_Chat_Data_Redirect: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uri: String = String()

    var message: String = String()

    var wait: SwiftProtobuf.Google_Protobuf_Duration {
        get {return _wait ?? SwiftProtobuf.Google_Protobuf_Duration()}
        set {_wait = newValue}
    }
    /// Returns true if `wait` has been explicitly set.
    var hasWait: Bool {return self._wait != nil}
    /// Clears the value of `wait`. Subsequent reads from it will return its default value.
    mutating func clearWait() {self._wait = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _wait: SwiftProtobuf.Google_Protobuf_Duration?
}

struct Dwango_Nicolive_Chat_Data_SimpleNotification: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var message: Dwango_Nicolive_Chat_Data_SimpleNotification.OneOf_Message?

    var ichiba: String {
        get {
            if case .ichiba(let v)? = message {return v}
            return String()
        }
        set {message = .ichiba(newValue)}
    }

    var quote: String {
        get {
            if case .quote(let v)? = message {return v}
            return String()
        }
        set {message = .quote(newValue)}
    }

    var emotion: String {
        get {
            if case .emotion(let v)? = message {return v}
            return String()
        }
        set {message = .emotion(newValue)}
    }

    var cruise: String {
        get {
            if case .cruise(let v)? = message {return v}
            return String()
        }
        set {message = .cruise(newValue)}
    }

    var programExtended: String {
        get {
            if case .programExtended(let v)? = message {return v}
            return String()
        }
        set {message = .programExtended(newValue)}
    }

    var rankingIn: String {
        get {
            if case .rankingIn(let v)? = message {return v}
            return String()
        }
        set {message = .rankingIn(newValue)}
    }

    var rankingUpdated: String {
        get {
            if case .rankingUpdated(let v)? = message {return v}
            return String()
        }
        set {message = .rankingUpdated(newValue)}
    }

    var visited: String {
        get {
            if case .visited(let v)? = message {return v}
            return String()
        }
        set {message = .visited(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Message: Equatable, Sendable {
        case ichiba(String)
        case quote(String)
        case emotion(String)
        case cruise(String)
        case programExtended(String)
        case rankingIn(String)
        case rankingUpdated(String)
        case visited(String)

    }

    init() {}
}

struct Dwango_Nicolive_Chat_Data_Gift: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var itemID: String = String()

    var advertiserUserID: Int64 {
        get {return _advertiserUserID ?? 0}
        set {_advertiserUserID = newValue}
    }
    /// Returns true if `advertiserUserID` has been explicitly set.
    var hasAdvertiserUserID: Bool {return self._advertiserUserID != nil}
    /// Clears the value of `advertiserUserID`. Subsequent reads from it will return its default value.
    mutating func clearAdvertiserUserID() {self._advertiserUserID = nil}

    var advertiserName: String = String()

    var point: Int64 = 0

    var message: String = String()

    var itemName: String = String()

    var contributionRank: Int32 {
        get {return _contributionRank ?? 0}
        set {_contributionRank = newValue}
    }
    /// Returns true if `contributionRank` has been explicitly set.
    var hasContributionRank: Bool {return self._contributionRank != nil}
    /// Clears the value of `contributionRank`. Subsequent reads from it will return its default value.
    mutating func clearContributionRank() {self._contributionRank = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _advertiserUserID: Int64?
    fileprivate var _contributionRank: Int32?
}

struct Dwango_Nicolive_Chat_Data_Nicoad: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var versions: Dwango_Nicolive_Chat_Data_Nicoad.OneOf_Versions?

    var v0: Dwango_Nicolive_Chat_Data_Nicoad.V0 {
        get {
            if case .v0(let v)? = versions {return v}
            return Dwango_Nicolive_Chat_Data_Nicoad.V0()
        }
        set {versions = .v0(newValue)}
    }

    var v1: Dwango_Nicolive_Chat_Data_Nicoad.V1 {
        get {
            if case .v1(let v)? = versions {return v}
            return Dwango_Nicolive_Chat_Data_Nicoad.V1()
        }
        set {versions = .v1(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Versions: Equatable, Sendable {
        case v0(Dwango_Nicolive_Chat_Data_Nicoad.V0)
        case v1(Dwango_Nicolive_Chat_Data_Nicoad.V1)

    }

    struct V0: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var latest: Dwango_Nicolive_Chat_Data_Nicoad.V0.Latest {
            get {return _latest ?? Dwango_Nicolive_Chat_Data_Nicoad.V0.Latest()}
            set {_latest = newValue}
        }
        /// Returns true if `latest` has been explicitly set.
        var hasLatest: Bool {return self._latest != nil}
        /// Clears the value of `latest`. Subsequent reads from it will return its default value.
        mutating func clearLatest() {self._latest = nil}

        var ranking: [Dwango_Nicolive_Chat_Data_Nicoad.V0.Ranking] = []

        var totalPoint: Int32 = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        struct Latest: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            var advertiser: String = String()

            var point: Int32 = 0

            var message: String {
                get {return _message ?? String()}
                set {_message = newValue}
            }
            /// Returns true if `message` has been explicitly set.
            var hasMessage: Bool {return self._message != nil}
            /// Clears the value of `message`. Subsequent reads from it will return its default value.
            mutating func clearMessage() {self._message = nil}

            var unknownFields = SwiftProtobuf.UnknownStorage()

            init() {}

            fileprivate var _message: String?
        }

        struct Ranking: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            var advertiser: String = String()

            var rank: Int32 = 0

            var message: String {
                get {return _message ?? String()}
                set {_message = newValue}
            }
            /// Returns true if `message` has been explicitly set.
            var hasMessage: Bool {return self._message != nil}
            /// Clears the value of `message`. Subsequent reads from it will return its default value.
            mutating func clearMessage() {self._message = nil}

            var userRank: Int32 {
                get {return _userRank ?? 0}
                set {_userRank = newValue}
            }
            /// Returns true if `userRank` has been explicitly set.
            var hasUserRank: Bool {return self._userRank != nil}
            /// Clears the value of `userRank`. Subsequent reads from it will return its default value.
            mutating func clearUserRank() {self._userRank = nil}

            var unknownFields = SwiftProtobuf.UnknownStorage()

            init() {}

            fileprivate var _message: String?
            fileprivate var _userRank: Int32?
        }

        init() {}

        fileprivate var _latest: Dwango_Nicolive_Chat_Data_Nicoad.V0.Latest?
    }

    struct V1: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var totalAdPoint: Int32 = 0

        var message: String = String()

        var unknownFields = SwiftProtobuf.UnknownStorage()
    }

    init() {}
}

struct Dwango_Nicolive_Chat_Data_CommentLock: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var status: Dwango_Nicolive_Chat_Data_CommentLock.Status = .unrestricted

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Status: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unrestricted // = 0
        case locked // = 1
        case UNRECOGNIZED(Int)

        init() {
            self = .unrestricted
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unrestricted
            case 1: self = .locked
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .unrestricted: return 0
            case .locked: return 1
            case .UNRECOGNIZED(let i): return i
            }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Dwango_Nicolive_Chat_Data_CommentLock.Status] = [
            .unrestricted,
            .locked
        ]

    }
}

struct Dwango_Nicolive_Chat_Data_CommentMode: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var layout: Dwango_Nicolive_Chat_Data_CommentMode.Layout = .normal

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Layout: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case normal // = 0
        case splitTop // = 1
        case background // = 2
        case UNRECOGNIZED(Int)

        init() {
            self = .normal
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .normal
            case 1: self = .splitTop
            case 2: self = .background
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .normal: return 0
            case .splitTop: return 1
            case .background: return 2
            case .UNRECOGNIZED(let i): return i
            }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Dwango_Nicolive_Chat_Data_CommentMode.Layout] = [
            .normal,
            .splitTop,
            .background
        ]

    }
}

struct Dwango_Nicolive_Chat_Data_GameUpdate: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()
}

struct Dwango_Nicolive_Chat_Data_TrialPanel: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var panel: Dwango_Nicolive_Chat_Data_TrialPanel.Panel = .hidden

    var unqualifiedUser: Dwango_Nicolive_Chat_Data_TrialPanel.Mode = .allowed

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Panel: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case hidden // = 0
        case display // = 1
        case UNRECOGNIZED(Int)

        init() {
            self = .hidden
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .hidden
            case 1: self = .display
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .hidden: return 0
            case .display: return 1
            case .UNRECOGNIZED(let i): return i
            }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Dwango_Nicolive_Chat_Data_TrialPanel.Panel] = [
            .hidden,
            .display
        ]

    }

    enum Mode: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case allowed // = 0
        case restricted // = 1
        case forbidden // = 2
        case UNRECOGNIZED(Int)

        init() {
            self = .allowed
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .allowed
            case 1: self = .restricted
            case 2: self = .forbidden
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .allowed: return 0
            case .restricted: return 1
            case .forbidden: return 2
            case .UNRECOGNIZED(let i): return i
            }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Dwango_Nicolive_Chat_Data_TrialPanel.Mode] = [
            .allowed,
            .restricted,
            .forbidden
        ]

    }
}

struct Dwango_Nicolive_Chat_Data_ProgramStatus: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var state: Dwango_Nicolive_Chat_Data_ProgramStatus.State = .unknown

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unknown // = 0
        case ended // = 1
        case UNRECOGNIZED(Int)

        init() {
            self = .unknown
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .ended
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .ended: return 1
            case .UNRECOGNIZED(let i): return i
            }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Dwango_Nicolive_Chat_Data_ProgramStatus.State] = [
            .unknown,
            .ended
        ]

    }
}

struct Dwango_Nicolive_Chat_Data_TagUpdated: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var tags: [Dwango_Nicolive_Chat_Data_TagUpdated.Tag] = []

    var ownerLocked: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Tag: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var text: String = String()

        var locked: Bool = false

        var reserved: Bool = false

        var nicopediaUri: String = String()

        var unknownFields = SwiftProtobuf.UnknownStorage()
    }

    init() {}
}

struct Dwango_Nicolive_Chat_Data_Statistics: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var viewers: Int64 {
        get {return _viewers ?? 0}
        set {_viewers = newValue}
    }
    /// Returns true if `viewers` has been explicitly set.
    var hasViewers: Bool {return self._viewers != nil}
    /// Clears the value of `viewers`. Subsequent reads from it will return its default value.
    mutating func clearViewers() {self._viewers = nil}

    var comments: Int64 {
        get {return _comments ?? 0}
        set {_comments = newValue}
    }
    /// Returns true if `comments` has been explicitly set.
    var hasComments: Bool {return self._comments != nil}
    /// Clears the value of `comments`. Subsequent reads from it will return its default value.
    mutating func clearComments() {self._comments = nil}

    var adPoints: Int64 {
        get {return _adPoints ?? 0}
        set {_adPoints = newValue}
    }
    /// Returns true if `adPoints` has been explicitly set.
    var hasAdPoints: Bool {return self._adPoints != nil}
    /// Clears the value of `adPoints`. Subsequent reads from it will return its default value.
    mutating func clearAdPoints() {self._adPoints = nil}

    var giftPoints: Int64 {
        get {return _giftPoints ?? 0}
        set {_giftPoints = newValue}
    }
    /// Returns true if `giftPoints` has been explicitly set.
    var hasGiftPoints: Bool {return self._giftPoints != nil}
    /// Clears the value of `giftPoints`. Subsequent reads from it will return its default value.
    mutating func clearGiftPoints() {self._giftPoints = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _viewers: Int64?
    fileprivate var _comments: Int64?
    fileprivate var _adPoints: Int64?
    fileprivate var _giftPoints: Int64?
}

struct Dwango_Nicolive_Chat_Data_Marquee: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var display: Dwango_Nicolive_Chat_Data_Marquee.Display {
        get {return _display ?? Dwango_Nicolive_Chat_Data_Marquee.Display()}
        set {_display = newValue}
    }
    /// Returns true if `display` has been explicitly set.
    var hasDisplay: Bool {return self._display != nil}
    /// Clears the value of `display`. Subsequent reads from it will return its default value.
    mutating func clearDisplay() {self._display = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Display: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var operatorComment: Dwango_Nicolive_Chat_Data_OperatorComment {
            get {return _operatorComment ?? Dwango_Nicolive_Chat_Data_OperatorComment()}
            set {_operatorComment = newValue}
        }
        /// Returns true if `operatorComment` has been explicitly set.
        var hasOperatorComment: Bool {return self._operatorComment != nil}
        /// Clears the value of `operatorComment`. Subsequent reads from it will return its default value.
        mutating func clearOperatorComment() {self._operatorComment = nil}

        var duration: SwiftProtobuf.Google_Protobuf_Duration {
            get {return _duration ?? SwiftProtobuf.Google_Protobuf_Duration()}
            set {_duration = newValue}
        }
        /// Returns true if `duration` has been explicitly set.
        var hasDuration: Bool {return self._duration != nil}
        /// Clears the value of `duration`. Subsequent reads from it will return its default value.
        mutating func clearDuration() {self._duration = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _operatorComment: Dwango_Nicolive_Chat_Data_OperatorComment?
        fileprivate var _duration: SwiftProtobuf.Google_Protobuf_Duration?
    }

    init() {}

    fileprivate var _display: Dwango_Nicolive_Chat_Data_Marquee.Display?
}

struct Dwango_Nicolive_Chat_Data_Enquete: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var question: String = String()

    var choices: [Dwango_Nicolive_Chat_Data_Enquete.Choice] = []

    var status: Dwango_Nicolive_Chat_Data_Enquete.Status = .closed

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Status: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case closed // = 0
        case poll // = 1
        case result // = 2
        case UNRECOGNIZED(Int)

        init() {
            self = .closed
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .closed
            case 1: self = .poll
            case 2: self = .result
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .closed: return 0
            case .poll: return 1
            case .result: return 2
            case .UNRECOGNIZED(let i): return i
            }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Dwango_Nicolive_Chat_Data_Enquete.Status] = [
            .closed,
            .poll,
            .result
        ]

    }

    struct Choice: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var description_p: String = String()

        var perMille: Int32 {
            get {return _perMille ?? 0}
            set {_perMille = newValue}
        }
        /// Returns true if `perMille` has been explicitly set.
        var hasPerMille: Bool {return self._perMille != nil}
        /// Clears the value of `perMille`. Subsequent reads from it will return its default value.
        mutating func clearPerMille() {self._perMille = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _perMille: Int32?
    }

    init() {}
}

struct Dwango_Nicolive_Chat_Data_MoveOrder: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var to: Dwango_Nicolive_Chat_Data_MoveOrder.OneOf_To?

    var jump: Dwango_Nicolive_Chat_Data_Jump {
        get {
            if case .jump(let v)? = to {return v}
            return Dwango_Nicolive_Chat_Data_Jump()
        }
        set {to = .jump(newValue)}
    }

    var redirect: Dwango_Nicolive_Chat_Data_Redirect {
        get {
            if case .redirect(let v)? = to {return v}
            return Dwango_Nicolive_Chat_Data_Redirect()
        }
        set {to = .redirect(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_To: Equatable, Sendable {
        case jump(Dwango_Nicolive_Chat_Data_Jump)
        case redirect(Dwango_Nicolive_Chat_Data_Redirect)

    }

    init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "dwango.nicolive.chat.data"

extension Dwango_Nicolive_Chat_Data_Chat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Chat"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "content"),
        3: .same(proto: "vpos"),
        4: .standard(proto: "account_status"),
        2: .same(proto: "name"),
        5: .standard(proto: "raw_user_id"),
        6: .standard(proto: "hashed_user_id"),
        7: .same(proto: "modifier"),
        8: .same(proto: "no")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.content) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
            case 3: try { try decoder.decodeSingularInt32Field(value: &self.vpos) }()
            case 4: try { try decoder.decodeSingularEnumField(value: &self.accountStatus) }()
            case 5: try { try decoder.decodeSingularInt64Field(value: &self._rawUserID) }()
            case 6: try { try decoder.decodeSingularStringField(value: &self._hashedUserID) }()
            case 7: try { try decoder.decodeSingularMessageField(value: &self._modifier) }()
            case 8: try { try decoder.decodeSingularInt32Field(value: &self.no) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !self.content.isEmpty {
            try visitor.visitSingularStringField(value: self.content, fieldNumber: 1)
        }
        try { if let v = self._name {
            try visitor.visitSingularStringField(value: v, fieldNumber: 2)
        } }()
        if self.vpos != 0 {
            try visitor.visitSingularInt32Field(value: self.vpos, fieldNumber: 3)
        }
        if self.accountStatus != .standard {
            try visitor.visitSingularEnumField(value: self.accountStatus, fieldNumber: 4)
        }
        try { if let v = self._rawUserID {
            try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
        } }()
        try { if let v = self._hashedUserID {
            try visitor.visitSingularStringField(value: v, fieldNumber: 6)
        } }()
        try { if let v = self._modifier {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
        } }()
        if self.no != 0 {
            try visitor.visitSingularInt32Field(value: self.no, fieldNumber: 8)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Data_Chat, rhs: Dwango_Nicolive_Chat_Data_Chat) -> Bool {
        if lhs.content != rhs.content {return false}
        if lhs.vpos != rhs.vpos {return false}
        if lhs.accountStatus != rhs.accountStatus {return false}
        if lhs._name != rhs._name {return false}
        if lhs._rawUserID != rhs._rawUserID {return false}
        if lhs._hashedUserID != rhs._hashedUserID {return false}
        if lhs._modifier != rhs._modifier {return false}
        if lhs.no != rhs.no {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Data_Chat.AccountStatus: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Standard"),
        1: .same(proto: "Premium")
    ]
}

extension Dwango_Nicolive_Chat_Data_Chat.Modifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Dwango_Nicolive_Chat_Data_Chat.protoMessageName + ".Modifier"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "position"),
        2: .same(proto: "size"),
        3: .standard(proto: "named_color"),
        4: .standard(proto: "full_color"),
        5: .same(proto: "font"),
        6: .same(proto: "opacity")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularEnumField(value: &self.position) }()
            case 2: try { try decoder.decodeSingularEnumField(value: &self.size) }()
            case 3: try {
                var v: Dwango_Nicolive_Chat_Data_Chat.Modifier.ColorName?
                try decoder.decodeSingularEnumField(value: &v)
                if let v = v {
                    if self.color != nil {try decoder.handleConflictingOneOf()}
                    self.color = .namedColor(v)
                }
            }()
            case 4: try {
                var v: Dwango_Nicolive_Chat_Data_Chat.Modifier.FullColor?
                var hadOneofValue = false
                if let current = self.color {
                    hadOneofValue = true
                    if case .fullColor(let m) = current {v = m}
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v {
                    if hadOneofValue {try decoder.handleConflictingOneOf()}
                    self.color = .fullColor(v)
                }
            }()
            case 5: try { try decoder.decodeSingularEnumField(value: &self.font) }()
            case 6: try { try decoder.decodeSingularEnumField(value: &self.opacity) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if self.position != .naka {
            try visitor.visitSingularEnumField(value: self.position, fieldNumber: 1)
        }
        if self.size != .medium {
            try visitor.visitSingularEnumField(value: self.size, fieldNumber: 2)
        }
        switch self.color {
        case .namedColor?: try {
            guard case .namedColor(let v)? = self.color else { preconditionFailure() }
            try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
        }()
        case .fullColor?: try {
            guard case .fullColor(let v)? = self.color else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        }()
        case nil: break
        }
        if self.font != .defont {
            try visitor.visitSingularEnumField(value: self.font, fieldNumber: 5)
        }
        if self.opacity != .normal {
            try visitor.visitSingularEnumField(value: self.opacity, fieldNumber: 6)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Data_Chat.Modifier, rhs: Dwango_Nicolive_Chat_Data_Chat.Modifier) -> Bool {
        if lhs.position != rhs.position {return false}
        if lhs.size != rhs.size {return false}
        if lhs.color != rhs.color {return false}
        if lhs.font != rhs.font {return false}
        if lhs.opacity != rhs.opacity {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Data_Chat.Modifier.Pos: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "naka"),
        1: .same(proto: "shita"),
        2: .same(proto: "ue")
    ]
}

extension Dwango_Nicolive_Chat_Data_Chat.Modifier.Size: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "medium"),
        1: .same(proto: "small"),
        2: .same(proto: "big")
    ]
}

extension Dwango_Nicolive_Chat_Data_Chat.Modifier.ColorName: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "white"),
        1: .same(proto: "red"),
        2: .same(proto: "pink"),
        3: .same(proto: "orange"),
        4: .same(proto: "yellow"),
        5: .same(proto: "green"),
        6: .same(proto: "cyan"),
        7: .same(proto: "blue"),
        8: .same(proto: "purple"),
        9: .same(proto: "black"),
        10: .same(proto: "white2"),
        11: .same(proto: "red2"),
        12: .same(proto: "pink2"),
        13: .same(proto: "orange2"),
        14: .same(proto: "yellow2"),
        15: .same(proto: "green2"),
        16: .same(proto: "cyan2"),
        17: .same(proto: "blue2"),
        18: .same(proto: "purple2"),
        19: .same(proto: "black2")
    ]
}

extension Dwango_Nicolive_Chat_Data_Chat.Modifier.Font: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "defont"),
        1: .same(proto: "mincho"),
        2: .same(proto: "gothic")
    ]
}

extension Dwango_Nicolive_Chat_Data_Chat.Modifier.Opacity: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Normal"),
        1: .same(proto: "Translucent")
    ]
}

extension Dwango_Nicolive_Chat_Data_Chat.Modifier.FullColor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Dwango_Nicolive_Chat_Data_Chat.Modifier.protoMessageName + ".FullColor"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "r"),
        2: .same(proto: "g"),
        3: .same(proto: "b")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularInt32Field(value: &self.r) }()
            case 2: try { try decoder.decodeSingularInt32Field(value: &self.g) }()
            case 3: try { try decoder.decodeSingularInt32Field(value: &self.b) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.r != 0 {
            try visitor.visitSingularInt32Field(value: self.r, fieldNumber: 1)
        }
        if self.g != 0 {
            try visitor.visitSingularInt32Field(value: self.g, fieldNumber: 2)
        }
        if self.b != 0 {
            try visitor.visitSingularInt32Field(value: self.b, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Data_Chat.Modifier.FullColor, rhs: Dwango_Nicolive_Chat_Data_Chat.Modifier.FullColor) -> Bool {
        if lhs.r != rhs.r {return false}
        if lhs.g != rhs.g {return false}
        if lhs.b != rhs.b {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Data_OperatorComment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".OperatorComment"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "content"),
        2: .same(proto: "name"),
        3: .same(proto: "modifier"),
        4: .same(proto: "link")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.content) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
            case 3: try { try decoder.decodeSingularMessageField(value: &self._modifier) }()
            case 4: try { try decoder.decodeSingularStringField(value: &self._link) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !self.content.isEmpty {
            try visitor.visitSingularStringField(value: self.content, fieldNumber: 1)
        }
        try { if let v = self._name {
            try visitor.visitSingularStringField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._modifier {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try { if let v = self._link {
            try visitor.visitSingularStringField(value: v, fieldNumber: 4)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Data_OperatorComment, rhs: Dwango_Nicolive_Chat_Data_OperatorComment) -> Bool {
        if lhs.content != rhs.content {return false}
        if lhs._name != rhs._name {return false}
        if lhs._modifier != rhs._modifier {return false}
        if lhs._link != rhs._link {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Data_Jump: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Jump"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "content"),
        2: .same(proto: "message"),
        4: .same(proto: "wait")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.content) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
            case 4: try { try decoder.decodeSingularMessageField(value: &self._wait) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !self.content.isEmpty {
            try visitor.visitSingularStringField(value: self.content, fieldNumber: 1)
        }
        if !self.message.isEmpty {
            try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
        }
        try { if let v = self._wait {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Data_Jump, rhs: Dwango_Nicolive_Chat_Data_Jump) -> Bool {
        if lhs.content != rhs.content {return false}
        if lhs.message != rhs.message {return false}
        if lhs._wait != rhs._wait {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Data_Redirect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Redirect"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "uri"),
        2: .same(proto: "message"),
        4: .same(proto: "wait")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
            case 4: try { try decoder.decodeSingularMessageField(value: &self._wait) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !self.uri.isEmpty {
            try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
        }
        if !self.message.isEmpty {
            try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
        }
        try { if let v = self._wait {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Data_Redirect, rhs: Dwango_Nicolive_Chat_Data_Redirect) -> Bool {
        if lhs.uri != rhs.uri {return false}
        if lhs.message != rhs.message {return false}
        if lhs._wait != rhs._wait {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Data_SimpleNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".SimpleNotification"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "ichiba"),
        2: .same(proto: "quote"),
        3: .same(proto: "emotion"),
        4: .same(proto: "cruise"),
        5: .standard(proto: "program_extended"),
        6: .standard(proto: "ranking_in"),
        8: .standard(proto: "ranking_updated"),
        7: .same(proto: "visited")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                var v: String?
                try decoder.decodeSingularStringField(value: &v)
                if let v = v {
                    if self.message != nil {try decoder.handleConflictingOneOf()}
                    self.message = .ichiba(v)
                }
            }()
            case 2: try {
                var v: String?
                try decoder.decodeSingularStringField(value: &v)
                if let v = v {
                    if self.message != nil {try decoder.handleConflictingOneOf()}
                    self.message = .quote(v)
                }
            }()
            case 3: try {
                var v: String?
                try decoder.decodeSingularStringField(value: &v)
                if let v = v {
                    if self.message != nil {try decoder.handleConflictingOneOf()}
                    self.message = .emotion(v)
                }
            }()
            case 4: try {
                var v: String?
                try decoder.decodeSingularStringField(value: &v)
                if let v = v {
                    if self.message != nil {try decoder.handleConflictingOneOf()}
                    self.message = .cruise(v)
                }
            }()
            case 5: try {
                var v: String?
                try decoder.decodeSingularStringField(value: &v)
                if let v = v {
                    if self.message != nil {try decoder.handleConflictingOneOf()}
                    self.message = .programExtended(v)
                }
            }()
            case 6: try {
                var v: String?
                try decoder.decodeSingularStringField(value: &v)
                if let v = v {
                    if self.message != nil {try decoder.handleConflictingOneOf()}
                    self.message = .rankingIn(v)
                }
            }()
            case 7: try {
                var v: String?
                try decoder.decodeSingularStringField(value: &v)
                if let v = v {
                    if self.message != nil {try decoder.handleConflictingOneOf()}
                    self.message = .visited(v)
                }
            }()
            case 8: try {
                var v: String?
                try decoder.decodeSingularStringField(value: &v)
                if let v = v {
                    if self.message != nil {try decoder.handleConflictingOneOf()}
                    self.message = .rankingUpdated(v)
                }
            }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch self.message {
        case .ichiba?: try {
            guard case .ichiba(let v)? = self.message else { preconditionFailure() }
            try visitor.visitSingularStringField(value: v, fieldNumber: 1)
        }()
        case .quote?: try {
            guard case .quote(let v)? = self.message else { preconditionFailure() }
            try visitor.visitSingularStringField(value: v, fieldNumber: 2)
        }()
        case .emotion?: try {
            guard case .emotion(let v)? = self.message else { preconditionFailure() }
            try visitor.visitSingularStringField(value: v, fieldNumber: 3)
        }()
        case .cruise?: try {
            guard case .cruise(let v)? = self.message else { preconditionFailure() }
            try visitor.visitSingularStringField(value: v, fieldNumber: 4)
        }()
        case .programExtended?: try {
            guard case .programExtended(let v)? = self.message else { preconditionFailure() }
            try visitor.visitSingularStringField(value: v, fieldNumber: 5)
        }()
        case .rankingIn?: try {
            guard case .rankingIn(let v)? = self.message else { preconditionFailure() }
            try visitor.visitSingularStringField(value: v, fieldNumber: 6)
        }()
        case .visited?: try {
            guard case .visited(let v)? = self.message else { preconditionFailure() }
            try visitor.visitSingularStringField(value: v, fieldNumber: 7)
        }()
        case .rankingUpdated?: try {
            guard case .rankingUpdated(let v)? = self.message else { preconditionFailure() }
            try visitor.visitSingularStringField(value: v, fieldNumber: 8)
        }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Data_SimpleNotification, rhs: Dwango_Nicolive_Chat_Data_SimpleNotification) -> Bool {
        if lhs.message != rhs.message {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Data_Gift: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Gift"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "item_id"),
        2: .standard(proto: "advertiser_user_id"),
        3: .standard(proto: "advertiser_name"),
        4: .same(proto: "point"),
        5: .same(proto: "message"),
        6: .standard(proto: "item_name"),
        7: .standard(proto: "contribution_rank")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.itemID) }()
            case 2: try { try decoder.decodeSingularInt64Field(value: &self._advertiserUserID) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self.advertiserName) }()
            case 4: try { try decoder.decodeSingularInt64Field(value: &self.point) }()
            case 5: try { try decoder.decodeSingularStringField(value: &self.message) }()
            case 6: try { try decoder.decodeSingularStringField(value: &self.itemName) }()
            case 7: try { try decoder.decodeSingularInt32Field(value: &self._contributionRank) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !self.itemID.isEmpty {
            try visitor.visitSingularStringField(value: self.itemID, fieldNumber: 1)
        }
        try { if let v = self._advertiserUserID {
            try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
        } }()
        if !self.advertiserName.isEmpty {
            try visitor.visitSingularStringField(value: self.advertiserName, fieldNumber: 3)
        }
        if self.point != 0 {
            try visitor.visitSingularInt64Field(value: self.point, fieldNumber: 4)
        }
        if !self.message.isEmpty {
            try visitor.visitSingularStringField(value: self.message, fieldNumber: 5)
        }
        if !self.itemName.isEmpty {
            try visitor.visitSingularStringField(value: self.itemName, fieldNumber: 6)
        }
        try { if let v = self._contributionRank {
            try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Data_Gift, rhs: Dwango_Nicolive_Chat_Data_Gift) -> Bool {
        if lhs.itemID != rhs.itemID {return false}
        if lhs._advertiserUserID != rhs._advertiserUserID {return false}
        if lhs.advertiserName != rhs.advertiserName {return false}
        if lhs.point != rhs.point {return false}
        if lhs.message != rhs.message {return false}
        if lhs.itemName != rhs.itemName {return false}
        if lhs._contributionRank != rhs._contributionRank {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Data_Nicoad: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Nicoad"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "v0"),
        2: .same(proto: "v1")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                var v: Dwango_Nicolive_Chat_Data_Nicoad.V0?
                var hadOneofValue = false
                if let current = self.versions {
                    hadOneofValue = true
                    if case .v0(let m) = current {v = m}
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v {
                    if hadOneofValue {try decoder.handleConflictingOneOf()}
                    self.versions = .v0(v)
                }
            }()
            case 2: try {
                var v: Dwango_Nicolive_Chat_Data_Nicoad.V1?
                var hadOneofValue = false
                if let current = self.versions {
                    hadOneofValue = true
                    if case .v1(let m) = current {v = m}
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v {
                    if hadOneofValue {try decoder.handleConflictingOneOf()}
                    self.versions = .v1(v)
                }
            }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch self.versions {
        case .v0?: try {
            guard case .v0(let v)? = self.versions else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }()
        case .v1?: try {
            guard case .v1(let v)? = self.versions else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Data_Nicoad, rhs: Dwango_Nicolive_Chat_Data_Nicoad) -> Bool {
        if lhs.versions != rhs.versions {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Data_Nicoad.V0: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Dwango_Nicolive_Chat_Data_Nicoad.protoMessageName + ".V0"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "latest"),
        2: .same(proto: "ranking"),
        3: .standard(proto: "total_point")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._latest) }()
            case 2: try { try decoder.decodeRepeatedMessageField(value: &self.ranking) }()
            case 3: try { try decoder.decodeSingularInt32Field(value: &self.totalPoint) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._latest {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        if !self.ranking.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.ranking, fieldNumber: 2)
        }
        if self.totalPoint != 0 {
            try visitor.visitSingularInt32Field(value: self.totalPoint, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Data_Nicoad.V0, rhs: Dwango_Nicolive_Chat_Data_Nicoad.V0) -> Bool {
        if lhs._latest != rhs._latest {return false}
        if lhs.ranking != rhs.ranking {return false}
        if lhs.totalPoint != rhs.totalPoint {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Data_Nicoad.V0.Latest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Dwango_Nicolive_Chat_Data_Nicoad.V0.protoMessageName + ".Latest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "advertiser"),
        2: .same(proto: "point"),
        3: .same(proto: "message")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.advertiser) }()
            case 2: try { try decoder.decodeSingularInt32Field(value: &self.point) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self._message) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !self.advertiser.isEmpty {
            try visitor.visitSingularStringField(value: self.advertiser, fieldNumber: 1)
        }
        if self.point != 0 {
            try visitor.visitSingularInt32Field(value: self.point, fieldNumber: 2)
        }
        try { if let v = self._message {
            try visitor.visitSingularStringField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Data_Nicoad.V0.Latest, rhs: Dwango_Nicolive_Chat_Data_Nicoad.V0.Latest) -> Bool {
        if lhs.advertiser != rhs.advertiser {return false}
        if lhs.point != rhs.point {return false}
        if lhs._message != rhs._message {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Data_Nicoad.V0.Ranking: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Dwango_Nicolive_Chat_Data_Nicoad.V0.protoMessageName + ".Ranking"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "advertiser"),
        2: .same(proto: "rank"),
        3: .same(proto: "message"),
        4: .standard(proto: "user_rank")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.advertiser) }()
            case 2: try { try decoder.decodeSingularInt32Field(value: &self.rank) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self._message) }()
            case 4: try { try decoder.decodeSingularInt32Field(value: &self._userRank) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !self.advertiser.isEmpty {
            try visitor.visitSingularStringField(value: self.advertiser, fieldNumber: 1)
        }
        if self.rank != 0 {
            try visitor.visitSingularInt32Field(value: self.rank, fieldNumber: 2)
        }
        try { if let v = self._message {
            try visitor.visitSingularStringField(value: v, fieldNumber: 3)
        } }()
        try { if let v = self._userRank {
            try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Data_Nicoad.V0.Ranking, rhs: Dwango_Nicolive_Chat_Data_Nicoad.V0.Ranking) -> Bool {
        if lhs.advertiser != rhs.advertiser {return false}
        if lhs.rank != rhs.rank {return false}
        if lhs._message != rhs._message {return false}
        if lhs._userRank != rhs._userRank {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Data_Nicoad.V1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Dwango_Nicolive_Chat_Data_Nicoad.protoMessageName + ".V1"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "total_ad_point"),
        2: .same(proto: "message")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularInt32Field(value: &self.totalAdPoint) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.totalAdPoint != 0 {
            try visitor.visitSingularInt32Field(value: self.totalAdPoint, fieldNumber: 1)
        }
        if !self.message.isEmpty {
            try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Data_Nicoad.V1, rhs: Dwango_Nicolive_Chat_Data_Nicoad.V1) -> Bool {
        if lhs.totalAdPoint != rhs.totalAdPoint {return false}
        if lhs.message != rhs.message {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Data_CommentLock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CommentLock"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "status")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.status != .unrestricted {
            try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Data_CommentLock, rhs: Dwango_Nicolive_Chat_Data_CommentLock) -> Bool {
        if lhs.status != rhs.status {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Data_CommentLock.Status: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Unrestricted"),
        1: .same(proto: "Locked")
    ]
}

extension Dwango_Nicolive_Chat_Data_CommentMode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CommentMode"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "layout")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularEnumField(value: &self.layout) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.layout != .normal {
            try visitor.visitSingularEnumField(value: self.layout, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Data_CommentMode, rhs: Dwango_Nicolive_Chat_Data_CommentMode) -> Bool {
        if lhs.layout != rhs.layout {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Data_CommentMode.Layout: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Normal"),
        1: .same(proto: "SplitTop"),
        2: .same(proto: "Background")
    ]
}

extension Dwango_Nicolive_Chat_Data_GameUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".GameUpdate"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Data_GameUpdate, rhs: Dwango_Nicolive_Chat_Data_GameUpdate) -> Bool {
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Data_TrialPanel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".TrialPanel"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "panel"),
        2: .standard(proto: "unqualified_user")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularEnumField(value: &self.panel) }()
            case 2: try { try decoder.decodeSingularEnumField(value: &self.unqualifiedUser) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.panel != .hidden {
            try visitor.visitSingularEnumField(value: self.panel, fieldNumber: 1)
        }
        if self.unqualifiedUser != .allowed {
            try visitor.visitSingularEnumField(value: self.unqualifiedUser, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Data_TrialPanel, rhs: Dwango_Nicolive_Chat_Data_TrialPanel) -> Bool {
        if lhs.panel != rhs.panel {return false}
        if lhs.unqualifiedUser != rhs.unqualifiedUser {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Data_TrialPanel.Panel: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Hidden"),
        1: .same(proto: "Display")
    ]
}

extension Dwango_Nicolive_Chat_Data_TrialPanel.Mode: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Allowed"),
        1: .same(proto: "Restricted"),
        2: .same(proto: "Forbidden")
    ]
}

extension Dwango_Nicolive_Chat_Data_ProgramStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ProgramStatus"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "state")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.state != .unknown {
            try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Data_ProgramStatus, rhs: Dwango_Nicolive_Chat_Data_ProgramStatus) -> Bool {
        if lhs.state != rhs.state {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Data_ProgramStatus.State: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Unknown"),
        1: .same(proto: "Ended")
    ]
}

extension Dwango_Nicolive_Chat_Data_TagUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".TagUpdated"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "tags"),
        2: .standard(proto: "owner_locked")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tags) }()
            case 2: try { try decoder.decodeSingularBoolField(value: &self.ownerLocked) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.tags.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.tags, fieldNumber: 1)
        }
        if self.ownerLocked != false {
            try visitor.visitSingularBoolField(value: self.ownerLocked, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Data_TagUpdated, rhs: Dwango_Nicolive_Chat_Data_TagUpdated) -> Bool {
        if lhs.tags != rhs.tags {return false}
        if lhs.ownerLocked != rhs.ownerLocked {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Data_TagUpdated.Tag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Dwango_Nicolive_Chat_Data_TagUpdated.protoMessageName + ".Tag"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "text"),
        2: .same(proto: "locked"),
        3: .same(proto: "reserved"),
        4: .standard(proto: "nicopedia_uri")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
            case 2: try { try decoder.decodeSingularBoolField(value: &self.locked) }()
            case 3: try { try decoder.decodeSingularBoolField(value: &self.reserved) }()
            case 4: try { try decoder.decodeSingularStringField(value: &self.nicopediaUri) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.text.isEmpty {
            try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
        }
        if self.locked != false {
            try visitor.visitSingularBoolField(value: self.locked, fieldNumber: 2)
        }
        if self.reserved != false {
            try visitor.visitSingularBoolField(value: self.reserved, fieldNumber: 3)
        }
        if !self.nicopediaUri.isEmpty {
            try visitor.visitSingularStringField(value: self.nicopediaUri, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Data_TagUpdated.Tag, rhs: Dwango_Nicolive_Chat_Data_TagUpdated.Tag) -> Bool {
        if lhs.text != rhs.text {return false}
        if lhs.locked != rhs.locked {return false}
        if lhs.reserved != rhs.reserved {return false}
        if lhs.nicopediaUri != rhs.nicopediaUri {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Data_Statistics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Statistics"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "viewers"),
        2: .same(proto: "comments"),
        3: .standard(proto: "ad_points"),
        4: .standard(proto: "gift_points")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularInt64Field(value: &self._viewers) }()
            case 2: try { try decoder.decodeSingularInt64Field(value: &self._comments) }()
            case 3: try { try decoder.decodeSingularInt64Field(value: &self._adPoints) }()
            case 4: try { try decoder.decodeSingularInt64Field(value: &self._giftPoints) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._viewers {
            try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._comments {
            try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._adPoints {
            try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
        } }()
        try { if let v = self._giftPoints {
            try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Data_Statistics, rhs: Dwango_Nicolive_Chat_Data_Statistics) -> Bool {
        if lhs._viewers != rhs._viewers {return false}
        if lhs._comments != rhs._comments {return false}
        if lhs._adPoints != rhs._adPoints {return false}
        if lhs._giftPoints != rhs._giftPoints {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Data_Marquee: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Marquee"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "display")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._display) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._display {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Data_Marquee, rhs: Dwango_Nicolive_Chat_Data_Marquee) -> Bool {
        if lhs._display != rhs._display {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Data_Marquee.Display: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Dwango_Nicolive_Chat_Data_Marquee.protoMessageName + ".Display"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "operator_comment"),
        3: .same(proto: "duration")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._operatorComment) }()
            case 3: try { try decoder.decodeSingularMessageField(value: &self._duration) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._operatorComment {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._duration {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Data_Marquee.Display, rhs: Dwango_Nicolive_Chat_Data_Marquee.Display) -> Bool {
        if lhs._operatorComment != rhs._operatorComment {return false}
        if lhs._duration != rhs._duration {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Data_Enquete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Enquete"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "question"),
        2: .same(proto: "choices"),
        3: .same(proto: "status")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.question) }()
            case 2: try { try decoder.decodeRepeatedMessageField(value: &self.choices) }()
            case 3: try { try decoder.decodeSingularEnumField(value: &self.status) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.question.isEmpty {
            try visitor.visitSingularStringField(value: self.question, fieldNumber: 1)
        }
        if !self.choices.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.choices, fieldNumber: 2)
        }
        if self.status != .closed {
            try visitor.visitSingularEnumField(value: self.status, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Data_Enquete, rhs: Dwango_Nicolive_Chat_Data_Enquete) -> Bool {
        if lhs.question != rhs.question {return false}
        if lhs.choices != rhs.choices {return false}
        if lhs.status != rhs.status {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Data_Enquete.Status: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Closed"),
        1: .same(proto: "Poll"),
        2: .same(proto: "Result")
    ]
}

extension Dwango_Nicolive_Chat_Data_Enquete.Choice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Dwango_Nicolive_Chat_Data_Enquete.protoMessageName + ".Choice"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "description"),
        3: .standard(proto: "per_mille")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
            case 3: try { try decoder.decodeSingularInt32Field(value: &self._perMille) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !self.description_p.isEmpty {
            try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 1)
        }
        try { if let v = self._perMille {
            try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Data_Enquete.Choice, rhs: Dwango_Nicolive_Chat_Data_Enquete.Choice) -> Bool {
        if lhs.description_p != rhs.description_p {return false}
        if lhs._perMille != rhs._perMille {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Dwango_Nicolive_Chat_Data_MoveOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".MoveOrder"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "jump"),
        2: .same(proto: "redirect")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                var v: Dwango_Nicolive_Chat_Data_Jump?
                var hadOneofValue = false
                if let current = self.to {
                    hadOneofValue = true
                    if case .jump(let m) = current {v = m}
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v {
                    if hadOneofValue {try decoder.handleConflictingOneOf()}
                    self.to = .jump(v)
                }
            }()
            case 2: try {
                var v: Dwango_Nicolive_Chat_Data_Redirect?
                var hadOneofValue = false
                if let current = self.to {
                    hadOneofValue = true
                    if case .redirect(let m) = current {v = m}
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v {
                    if hadOneofValue {try decoder.handleConflictingOneOf()}
                    self.to = .redirect(v)
                }
            }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch self.to {
        case .jump?: try {
            guard case .jump(let v)? = self.to else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }()
        case .redirect?: try {
            guard case .redirect(let v)? = self.to else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Dwango_Nicolive_Chat_Data_MoveOrder, rhs: Dwango_Nicolive_Chat_Data_MoveOrder) -> Bool {
        if lhs.to != rhs.to {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}
